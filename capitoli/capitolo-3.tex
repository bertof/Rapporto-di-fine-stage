%**************************************************************
% Capitolo 3 - COSA-COME - Il prodotto dello stage
%**************************************************************
\chapter{Il prodotto\label{cap:ilprodotto}}
In questo capitolo contiene informazioni sul progetto, le sue fasi, i suoi prodotti e il lavoro che è stato compiuto durante il tirocinio.

\section{Acquisizione delle conoscenze settoriali}
La prima fase del progetto ha avuto come argomento centrale l'acquisizione delle conoscenze del campo che ancora non avevo o di cui necessitavo approfondimenti. Ho eseguito questi studi in modo autonomo, ricercando gli argomenti in Internet e su libri e appunti dei corsi di laurea.

	\subsection{Codifica video}
	Un video digitale è definito come la codifica numerica di un segnale video; la codifica è, dunque, l'azione di trasformare un segnale video in un formato digitale. Questa operazione è effettuata da un \engl{software} o da un dispositivo elettronico detto \engl{codec}. Generalmente, i \engl{codec} eseguono anche compressione lossy, ovvero con perdita di informazioni, in modo tale da ridurre i dati necessari per trasmettere o salvare i flussi video. Esistono anche \engl{codec} che mantengono inalterata la quantità di informazione; questi vengono definiti \engl{lossless}.
	\paragraph*{}
	Esistono due famiglie di \engl{codec}, quelli intraframe e quelli interframe:
	i primi descrivono i \engl{frame} di un video singolarmente, trattandoli come immagini statiche; i secondi, invece, descrivono i cambiamenti che occorrono tra un fotogramma e l'altro, partendo da \engl{frame} chiave descritti con codifica intraframe. I \engl{codec} intraframe risultano, quindi più adatti alla descrizione di scene molto movimentate, senza perdita di qualità, mentre quelli interframe sono più adatti nel caso di sequenze per lo più statiche, per la loro notevole efficienza nel descrivere i pochi cambiamenti avvenuti.

	\subsection{Formati video comunemente usati}
		\subsubsection{M-JPEG}
			Motion \gls{JPEG}	è un \engl{codec} video che comprime ogni \engl{frame} del video originale in una immagine in formato \gls{JPEG}, un comune formato di compressione con perdita per immagini digitali. Originariamente creato per applicazioni multimediali, M-JPEG è attualmente utilizzato da dispositivi di videoregistrazione come camere digitali, IPcam e webcam.
			\paragraph*{}
			Un grande vantaggio dell'utilizzo di M-JPEG per la codifica video, che ha spinto la sua diffusione sulla maggior parte delle prime fotocamere digitali non professionali, è quello della bassa potenza di calcolo necessaria al suo utilizzo: è sufficiente una modifica \engl{software} all'encoder \engl{hardware} per \gls{JPEG} per poter creare un \engl{codec} M-JPEG.\@ Inoltre, permette la lettura non lineare del file, utile nel caso di sistemi di \engl{video editing}. Inoltre l'\engl{encoding} intraframe che sfrutta limita l'informazione contenuta in ciascun \engl{frame} M-JPEG a quella di un \engl{frame} del video originale, permettendo di cambiare velocemente il contenuto, senza considerare i \engl{frame} precedenti o successivi, come invece accade nelle codifiche interframe come H.264/MPEG-4 AVC.\@
			\paragraph*{}
			Con l'accrescere della potenza di calcolo, M-JPEG	è stato soppiantato da MPEG-4, per la resa qualitativamente molto migliore a parità di \engl{bitrate}, infatti \gls{JPEG} è inefficiente nello spazio di archiviazione. Inoltre M-JPEG non sfrutta tecniche di predizione spaziale, come H.264/MPEG-4 AVC, che permetterebbero un ulteriore risparmio di spazio, a discapito di una maggiore potenza di calcolo necessaria.

		\subsubsection{MPEG-1}
			MPEG-1 è uno \engl{standard} per la compressione con perdita di video e audio progettato per comprimere video con la qualità variabile tra il video di una \gls{VHS} e l'audio di un \gls{CD} fino a 1.5Mbit/s senza perdita di qualità eccessive, permettendo la creazione di video \gls{CD}, trasmissioni TV via satellite e via cavo e \gls{DAB}. Attualmente, MPEG-1 è il formato \engl{lossy} con più supporto di compatibilità al mondo e uno degli \engl{standard} che ha introdotto più noti è stato il formato audio MP3.
			\paragraph*{}
			MPEG-1 introduce molte tecnologie, frutto di studi statistici, che gli permettono di risparmiare molti dati per descrivere lo stesso video con poca perdita di qualità: innanzitutto l'utilizzo della \gls{trasformata DCT} su blocchi di \(8\cdot8\) permette di ottenere coefficienti tra loro incorrelati e solo alcuni di questi sono dominanti, permettendo un alto livello di compressione. I coefficienti \gls{DCT} ottenuti vengono quantizzati, con una grana più fine nelle frequenze più basse e con una più grossa nelle frequenze più alte. Queste influiscono meno sul risultato finale e il loro annullamento permette di diminuire il \engl{bitrate} complessivo senza pesanti perdite di qualità.
			Data la grande quantità di zeri dovuti alla quantizzazione, si utilizza una codifica run-length, ovvero si indicano i valori a coppie (a, b), dove a rappresenta il valore di un coefficiente non nullo e b il numero di zeri che lo precedono. Si sfrutta infine una codifica entropica basata su una tabella di valori standardizzati, ottenuti con un approccio basato sulla codifica di Huffman.

		\subsubsection{MPEG-4}
			MPEG-4 è basato sugli \engl{standard} MPEG-1, MPEG-2 e QuickTime. Si è osservato che, in caso di video con sezioni statiche o relativamente statiche, molti \engl{frame} sono riproducibili dai precedenti. È stata, quindi, realizzata una tecnica che sfrutta la somiglianza tra \engl{frame} vicini per risparmiare spazio nella codifica. Questa si ottiene indicando alcuni \engl{frame} come \engl{frame} chiave (I-Frame) e generando i \engl{frame} seguenti come trasformazioni del \engl{frame} principale
			\paragraph*{}
			MPEG-4 permette di creare oggetti multimediali con migliori capacità di adattamento e flessibilità, in grado di migliorare la qualità del risultato finale; inoltre è in grado di adattare la propria qualità sia a \engl{stream} a basso \engl{bitrate}, anche 1 Mbit/s, fino a formati ad alta risoluzione, come 4K e 8K.
			\paragraph*{}
			Le sue ottime performance di qualità e compressione costano in potenza computazionale, a causa della complessità della fase di quantizzazione; al contrario, la decodifica per la riproduzione è sufficientemente rapida e poco costosa, grazie anche a decodificatori \engl{hardware} specializzati, ormai comunemente integrati nella maggior parte dei processori.

		\subsubsection{WebM}
			WebM è un formato video \engl{royalty-free} pensato per il web, rilasciato sotto licenza \gls{BSD}, il cui sviluppo è sponsorizzato da Google. WebM sfrutta il motore di codifica VP9 e audio Opus ed è supportato nativamente dai maggiori browser, inclusi quelli dei dispositivi \engl{mobile}. WebM punta ad una migliore efficienza di compressione rispetto a MPEG-4 e sta sostituendo \gls{GIF} come formato di animazione video. Mentre il formato è libero, i motori VP8 e VP9 sono patentati Google e solo nel 2013 \gls{MPEG} LA ha raggiunto un accordo con la multinazionale per la licenza delle componenti essenziali all'implementazione dei \engl{codec}. Le attuali implementazioni libere (libvpx) mostrano un significativo vantaggio nei tempi di codifica e nel risparmio di \engl{bitrate} rispetto a MPEG-4 H.264 e H.265.

	\subsection{Protocolli}
	Un protocollo di rete è un protocollo di comunicazione utilizzato da in una rete informatica, ovvero la definizione formale a priori delle modalità di interazione tra due o più apparecchiature elettroniche devono utilizzare per poter comunicare tra di loro tramite una rete.

		\subsubsection{Protocolli per il video \engl{streaming}}
			Quando parliamo di protocolli di rete possiamo dividerli due categorie in base al tipo di trasmissione che utilizzano, ovvero se \engl{stream-oriented} o \engl{message-oriented}. Questa differenza, riscontrata al \engl{Transport Layer} della pila \gls{OSI}, è la base dei due più famosi protocolli di quel livello: \gls{TCP} e \gls{UDP}.\@
			\begin{figure}[H]
				\begin{center}
					\includegraphics[width=16.5cm,height=8cm,keepaspectratio]{immagini/tcp-udp-connections}	
					\caption[Schema di connessione di TCP e UDP]{Schema di connessione di \gls{TCP} e \gls{UDP}
					\\
					Adattato da: Wikimedia commons, Khandarmaa, CC BY-SA}
				\end{center}
			\end{figure}
			\paragraph*{} \gls{TCP} appartiene alla prima categoria: provvede alla realizzazione dei una connessione affidabile, nella quale i dati vengono suddivisi in pacchetti ordinati e in caso di errori di trasmissione il ricevente può richiederne il reinvio. Questo protocollo è pensato per la consistenza dei dati e assicura che le informazioni richieste arrivino tutte, integre e nell'ordine corretto al ricevente.
			\paragraph*{}
			\gls{UDP}, al contrario, appartiene al secondo genere: utilizza un modello \engl{connectionless}, pensato per messaggi atomici, e non garantisce che l'ordine di invio di un certo numero di pacchetti sia lo stesso con il quale vengono ricevuti. Inoltre, il protocollo non ha particolari misure di prevenzione della corruzione dei dati, se non un checksum dei contenuti del pacchetto, che ne permette la verifica di integrità.
			\paragraph*{}
			Nel caso di applicazioni di \engl{streaming} è importante nominare anche il protocollo \gls{SCTP}: si tratta di un protocollo \engl{message-oriented} e \engl{connectionless}, simile a \gls{UDP}, ma che aggiunge alcune feature di \gls{TCP}, come l'ordinamento dei pacchetti e la richiesta di reinvio. Questo permette al ricevente di mantenere la coerenza dei dati, anche in caso di messaggi lunghi, e di ricevere più \engl{stream} di pacchetti in parallelo.

		\subsubsection{Tipologie di streaming}
			Nel caso applicativo dello \engl{streaming} video si riscontrano due possibili situazioni:
			nel caso di \engl{streaming} \engl{real-time} l'obiettivo è quello di trasmettere un video con una latenza molto bassa, anche a discapito della qualità video; si pensi, ad esempio, quanto è negativa l'esperienza di un utente che durante una videoconferenza si accorge che un altro utente deve aspettare del tempo prima di ricevere la propria registrazione.
			\paragraph*{}
			Altro caso è quello dello \engl{streaming} \engl{on-demand}, nel quale un utente richiede l'accesso ad una risorsa video remota e la sua visualizzazione deve essere riportata con la qualità nativa; in questo caso l'utente è disposto ad aspettare qualche secondo di precaricamento iniziale, ma risulta particolarmente infastidito dalle interruzioni, magari a causa del \engl{buffering}.
			\paragraph*{}
			Nel primo caso il protocollo ideale è quello che trasmette con il \engl{bitrate} più alto possibile e con la massima frequenza di invio di messaggi; infatti il solo \engl{bitrate} non basta, una frequenza di invio alta permette di limitare la latenza alla sorgente del segnale, rimpicciolendo il tempo di attesa tra un intervallo e il successivo. Per questo tipo di trasmissioni il protocollo il protocollo più adatto è \gls{UDP}, per la dimensione variabile del messaggio, la piccola dimensione del suo \engl{header} e l'assenza di garanzie di consistenza non fondamentali, come la certezza che tutti i dati siano stati ricevuti. Sono nati quindi numerosi protocolli per l'\engl{Application Layer} \gls{OSI} basati su \gls{UDP}, adattati alla trasmissione di \engl{streaming} video, come \gls{RTP}, \gls{RTSP}, \gls{RTMP}.\@ A questo tipo di protocolli vengono spesso associati protocolli di controllo, come \gls{RTMCP} e \gls{RRCP}, che permettono a trasmittente e ricevente di accordarsi sul formato dei dati e sul \engl{bitrate} da utilizzare.
			\paragraph*{}
			Nel secondo caso il protocollo deve garantire la consistenza e l'integrità della trasmissione, pur mantenendo un \engl{bitrate} elevato. Questo tipo di trasmissione può essere ottenuta tramite un protocollo \engl{stream-oriented}, come quello di \gls{TCP}.\@ Nascono, quindi, anche nel caso di TCP protocolli per l'\engl{Application Layer} \gls{OSI} progettati per \engl{stream} di video, come \gls{MPEG-DASH}, \gls{HLS} di Apple e Microsoft Smooth Streaming. Per risolvere il problema delle interruzioni, molti servizi lasciano al \engl{client} la possibilità di caricare dinamicamente più di una versione dello stesso contenuto, in base alla disponibilità di bandwidth.
			\paragraph*{}
			Esiste infine un ulteriore funzionalità che sta diventando comune nei servizi più grandi: quella dello \engl{streaming} ibrido. Il servizio si basa su \engl{streaming} \engl{real-time}, ma permette agli utenti di rivedere una scena già trasmessa, comportandosi come uno \engl{streaming} \engl{on-demand}. Questo tipo di servizio richiede che il contenuto registrato venga salvato e velocemente diffuso all'interno della piattaforma, per poi essere reso disponibile, come per i restanti contenuti \engl{on-demand}.

		\subsubsection{UDP e i problemi di \engl{firewall}}
			Sebbene i protocolli basati su \gls{UDP} siano particolarmente adatti alle comunicazioni \engl{real-time}, soffrono di un grave problema legato alle regole applicate ai \engl{firewall}, specialmente nel caso di reti pubbliche o aziendali: capita molto spesso che per evitare minacce proveniente da reti esterne gli amministratori decidano di bloccare tutti, o quasi, i pacchetti UDP in entrata, a meno di risposta ad una chiamata proveniente dall'interno. Questa pratica è diventata molto comune, tanto che anche servizi di \engl{streaming}, come YouTube e Twitch, o di telecomunicazione, come Skype o Hangouts, siano stati costretti ad incapsulare il contenuto dei propri pacchetti \gls{UDP} in pacchetti \gls{TCP}, per superare le protezioni e offrire i propri servizi.

		\subsubsection{WebRTC}
			WebRTC è un insieme di protocolli di rete che permettono l'invio di messaggi in \engl{real-time} tramite connessioni \engl{peer-to-peer}. Il sistema è pensato per essere integrato nativamente nei browser, in modo tale da poter essere utilizzato, tramite un'interfaccia, da \engl{webapp} apposite per comunicare con componenti di backend e browser di altri utenti. WebRTC sfrutta il protocollo \gls{RTP}, per il trasferimento di audio e video, e lo stato attuale del suo supporto da parte dei principali browser è quasi totale: solo vecchie versioni di Internet Explorer e Safari non lo supportano, se non tramite plugin. Sebbene questa tecnologia sia standardizzata e il suo impiego sia sempre più frequente da parte di servizi di \engl{videochat}, le sue implementazioni per le piattaforme Android e iOS sono ancora acerbe e poco documentate; per questo motivo è ancora comune definire un protocollo di comunicazione specifico per l'applicazione, piuttosto di utilizzare questo \engl{standard}.
			\begin{figure}[H]
				\begin{center}
					\includegraphics[width=16.5cm,height=15cm,keepaspectratio]{immagini/webrtc-schema}
					\caption{Schema generale del funzionamento di WebRTC}
				\end{center}
			\end{figure}

	\subsection{Architettura di una piattaforma di \engl{streaming}}
		\subsubsection{Struttura di massima}
			Una piattaforma di video \engl{streaming} si compone di cinque elementi principali:
			\begin{itemize}
			\item La rete di \engl{inbound}, ovvero il sistema di reti che gestisce l'ingresso di dati nella piattaforma, siano questi file video o \engl{stream};
			\item Il motore di codifica, che permette di ricodificare i video in ingresso per renderli disponibili nei formati opportuni ai passaggi successivi.
			\item Il sistema di \engl{storage}, per il salvataggio dei contenuti per la breve, media e lunga conservazione;
			\item Il sistema di gestione e ricerca dei contenuti, che permette agli utenti di caricare, cercare e riprodurre i contenuti di proprio interesse;
			\item Il sistema di distribuzione dei contenuti, ovvero la rete che si occupa della trasmissione di dati ai \engl{client}.
			\end{itemize}

			\begin{figure}[H]
				\begin{center}
					\includegraphics[width=16.5cm,keepaspectratio]{immagini/schema-architettura-piattaforma-streaming}
					\caption{Schema generale di una piattaforma di \engl{streaming}}
				\end{center}
			\end{figure}

		\subsubsection{Inbound e transcodifica}
			La rete di \engl{inbound} è la parte del sistema che si occupa di accettare file e \engl{stream} da parte degli utenti e di inoltrarli ai nodi sottostanti. Questa componente è soggetta ai tipici problemi delle applicazioni web con un numero di utenti rilevante, ovvero la stabilità del servizio, la necessità di reti ad alta disponibilità, il bilanciamento del carico di lavoro tra i nodi sottostanti.
			\paragraph*{}
			I contenuti caricati tramite il sistema di \engl{inbound} vengono, poi, inviati ai motori di codifica, componenti specializzati nell'\engl{encoding} dei video. A seconda del tipo di input è possibile scegliere se utilizzare un \gls{transcodificatore} per lo \engl{streaming}, in grado di rielaborare il formato video di uno \engl{stream} ``al volo'' e con poca latenza aggiuntiva, oppure, nel caso di file video, questi vengono caricati in \engl{storage} temporanei e successivamente elaborati da \glspl{transcodificatore} comuni.

		\subsubsection{Storage e organizzazione dei contenuti}
			Il sistema di \engl{storage} si occupa dell'organizzazione dei contenuti, del loro salvataggio e del loro recupero. Al semplice \engl{filesystem} viene associato un \engl{database}, spesso non relazionale, per la gestione di metadati, testi, commenti e dati aggiuntivi. Il sistema deve consentire una veloce ed efficace ricerca dei contenuti, per permettere agli utenti di accedere alle informazioni volute.
			\\
			L'organizzazione di una tale mole di dati non è banale e sono spesso utilizzate tecnologie di analisi del testo e degli argomenti simili a quelle nei motori di ricerca per il web; in questo modo è possibile suggerire all'utente contenuti che potrebbe, effettivamente, essere interessato a consumare, aumentando il tempo di persistenza sulla piattaforma e le probabilità che questo ritorni in futuro.

		\subsubsection{Outbound, protocolli e \gls{CDN}}
			Nel caso della distribuzione di contenuti verso i \engl{client} sono generalmente utilizzati protocolli basati su \gls{TCP}, come \gls{MPEG-DASH}, Apple \gls{HLS} e Microsoft Smooth Streaming. Questo tipo di protocolli permettono più \engl{stream} paralleli e la possibilità di eseguire caching dei contenuti trasmessi, particolarmente utili nel caso di utilizzo di \gls{CDN} per estendere la distribuzione. Queste reti, solitamente di proprietà delle aziende di telecomunicazione su cui poggiano gli \gls{ISP}, offrono un servizio di caching che permette di spostare il carico di rete dovuto all'accesso ai contenuti dai server principali del servizio a server più piccoli e dislocati sul territorio. Questo tipo di distribuzione, non solo diminuisce il carico di rete, limitato quindi alla sola autorizzazione all'accesso, ma permette di avere latenza e tempi di caricamento minori da parte degli utenti.			

		\subsubsection{Message relay}
			Esistono casi di servizi di \engl{streaming} che devono permettere il reinvio di dati tra due \engl{client}, senza alcuna modifica ai contenuti trasmessi; in questo caso di parla di message \engl{relay}. Questo tipo di servizio è fondamentale se i due \engl{client} non possono comunicare direttamente, magari perché bloccati da \engl{firewall} o nascosti da una rete con \gls{NAT}.\@

		\subsubsection{Servizi annessi}
			Molte piattaforme di \engl{streaming} non si limitano alla sola trasmissione di contenenti ma offrono anche un certo numero di servizi annessi. In particolare le informazioni legate alla demografia degli utenti e alla loro profilazione sono di particolare interesse per i creatori. Inoltre sono comuni servizi di monetizzazione e annunci pubblicitari, cifratura dei contenuti e sistemi \gls{DRM}.\@


	\subsection{Trasmissione dei contenuti in mobilità}
			La quantità di utenti che consumano contenuti multimediali su applicazioni \engl{mobile} sempre più in aumento, tanto che nel Novembre 2016 si è registrato il sorpasso della quantità di utenti su tali piattaforme, rispetto ai \engl{desktop}\cite{mobiledesktopusage}. È in crescita anche l'utilizzo di questi dispositivi per eseguire live \engl{stream}, specialmente legati a social network, come Twitter, Facebook e Google+.
			L'utilizzo di dispositivi \engl{mobile} aggiunge un ulteriore strato di complessità alla comunicazione con i servizi web, come anche le piattaforme di \engl{streaming}.
			Le difficoltà maggiori che si incontrano in questo campo sono la limitata potenza computazionale dei dispositivi e autonomia energetica, i limiti imposti da una rete senza fili e la grande frammentazione dei sistemi, specialmente quando si tratta di Android.
			La maggior parte dei problemi precedentemente citati viene gestito dal sistema operativo, ma restano le limitazioni fisiche, ovvero la velocità di trasferimento dei dati:
	\subsection{Reti per dispositivi \engl{mobile}}
			Le principali reti disponibili per dispositivi \engl{mobile} possono essere riassunte nelle seguenti:
		\subsubsection{LTE --- 4G}
			\gls{LTE}, lo \engl{standard} commerciale di quarta generazione per le telecomunicazioni \engl{mobile}, supporta \engl{downlink} con velocità di picco di 300 Mbit/s e \engl{uplink} di 75 Mbit/s in caso di posizione statica. Questo tipo di connessione è ampiamente sufficiente alla trasmissione di video in alta risoluzione e alto framerate. \gls{LTE} ha lo svantaggio di essere soggetto a forti interferenze quando deve attraversare materiali solidi come muri o persone.
		\subsubsection{Wi-Fi}
			L'ultimo \engl{standard} Wi-Fi, \acrshort{IEEE} 802.11ac, ormai comunemente supportato dai dispositivi \engl{mobile} in commercio, raggiunge una velocità di trasmissione di circa un Gbit/s. Il precedente \engl{standard}, \acrshort{IEEE} 802.11n, era limitato a 300 Mbit/s tramite l'utilizzo di sistemi ad antenna multipla. Anche Wi-Fi è soggetto ad interferenze, specialmente quando utilizzato sulle frequenze più alte, a 5GHz. Oltre alla comune connessione a infrastruttura, \acrshort{IEEE} 802.11 supporta anche connessioni \engl{peer-to-peer} tramite il protocollo Wi-Fi Direct, che riduce i consumi e massimizza il throughput.
		\subsubsection{Bluetooth}
			Bluetooth 5 ha un throughput molto più basso dei precedenti canali di comunicazione; raggiunge, infatti, circa 50 Mbit/s, un \engl{bitrate} appena sufficiente alla trasmissione di video HD, al contrario, però, la distanza tra il trasmittente e il ricevente è molto più ridotto. Il vantaggio principale di Bluetooth è quello di utilizzare una minore quantità di energia elettrica per comunicare con altri dispositivi.

\subsection{Nuovi orizzonti}
Tra gli obiettivi desiderabili indicati dall'azienda sono presenti lo studio di alcuni campi innovativi e la possibilità di utilizzarli nel contesto dello \engl{streaming} video. Seguono i risultati dei miei studi e delle mie ricerche a riguardo.

	\subsubsection{Blockchain}
	\engl{Blockchain} è una tecnologia che permette di rendere delle informazioni pubbliche virtualmente impossibili da alterare. Il sistema si basa su catene di nodi distribuite in una rete \engl{peer-to-peer}; ogni nodo contiene una certa quantità di informazioni fissata, un numero intero variabile, detto nonce, e l'hash dell'ultimo nodo della catena.
	\begin{figure}[H]
		\begin{center}
			\includegraphics[width=16.5cm,keepaspectratio]{immagini/blockchain-data}
			\caption[Schema di funzionamento di una blockchain]{Schema di funzionamento di una blockchain
			\\
			Source: Wikimedia commons, Matthäus Wander, CC BY-SA 3.0}
		\end{center}
	\end{figure}
	\paragraph*{} Tutte le informazioni contenute nella catena sono pubblicamente accessibili e vengono condivise tra i \engl{client} che sono connessi alla rete. La catena può essere estesa con nuovi nodi, ma affinché un nodo sia valido il suo hash deve soddisfare una regola nota a tutti i \engl{client}. In generale questa impone che un certo numero di cifre in posizione fissata dell'hash siano uguali tra di loro e l'unico modo per far variare il risultato è cambiare il valore del numero intero all'interno dei dati. Dato che una funzione di hash è difficilmente reversibile, ovvero non è possibile ottenere i dati in input della funzione partendo dall'output, la complessità di questa operazione è molto alta e con l'aumentare del numero di cifre diventa sempre più difficile trovare un valore corretto. La regola della complessità varia in funzione del tempo necessario alla comunità di utenti per generare un nodo: con lo sviluppo di \engl{hardware} in grado di eseguire le operazioni necessarie più velocemente, il sistema si adatterà rendendo più difficile il \engl{mining}.
	\paragraph*{} Quando un \engl{client} riesce a generare un nodo adatto trasmette i valori adatti a dei server detti beacon, che accertano la correttezza del risultato e marcano l'istante temporale in cui il nodo è ritenuto valido, condividendo l'informazione a tutti i \engl{client} vicini. Questi inizieranno a lavorare sul prossimo nodo della catena, mentre l'utente che ha scoperto il nodo ottiene dei vantaggi: ad esempio, nel caso di Bitcoin guadagna una ricompensa economica. In qualsiasi momento è possibile convalidare la creazione dei nodi precedenti applicando la funzione di hash su un nodo; inoltre tanto più la catena di nodi si allunga, tanto più è improbabile che qualcuno sia riuscito ad alterare l'intera sequenza, dato che questo richiederebbe l'aver trovato i valori corretti per generare ogni nodo in essa.
	\paragraph*{}
	La possibilità di rendere alcuni dati pubblici immodificabili può essere molto utile in molti campi, ma nel caso dello \engl{streaming} affronta dei limiti molto importanti: mentre potrebbe essere possibile salvare interi file video all'interno di un singolo nodo, il throughput di questo metodo è molto basso a causa del tempo necessario al \engl{mining} del nuovo blocco. Si pensi che il tempo medio di generazione di un nodo di Bitcoin si aggira intorno agli otto minuti e trenta secondi. Un altro punto critico è il motivo che dovrebbe spingere gli utenti a eseguire le operazioni di hashing, ovvero la ricompensa: nel caso di un sistema di criptovaluta si può guadagnare denaro, ma parlando di \engl{streaming} video non c'è una ricompensa ovvia.
	\\
	Una soluzione potrebbe essere quella di ottenere crediti per l'utilizzo del servizio, oppure un certo valore monetario; il problema di questo approccio è che potrebbe non essere autocontenuto nella sola piattaforma, limitandone l'efficacia e l'interesse. Esistono, inoltre, soluzioni meno onerose per la condivisione di file video su grande scala in modo decentralizzato, pur mantenendo la consistenza dei dati, come ad esempio il sistema Torrent, che permette di suddividere delle informazioni in blocchi cifrati univocamente identificati e di condividerli con chiunque ne faccia richiesta; in questo modo è comunque possibile garantire che il contenuto di ciascun blocco non sia stato alterato, senza necessità della complessità aggiunta da una blockchain.

	\subsubsection{Streaming peer to peer}
	Un nuovo sistema di distribuzione, particolarmente efficace se accoppiato ad una \gls{CDN}, è quello di aggiungere al \engl{client} una componente che permetta la condivisione dei chunk di video scaricati tramite una rete \engl{peer-to-peer}. Gli utenti connessi diventano così parte della \gls{CDN} migliorando aumentandone la portata in modo lineare seguendo la crescita della base di utenza.
	\\
	Esistono già soluzioni commerciali che adottano questo tipo di soluzione, ottenendo una grande riduzione del carico di rete sui server adibiti alla distribuzione e, di conseguenza, diminuendo i costi di gestione.
	\paragraph*{}
	Ho avuto modo di conoscere anche soluzioni interamente \engl{peer-to-peer}, come quella ideata dagli sviluppatori di WebTorrent\footnote{Sito web di WebTorrent: \href{https://webtorrent.io/}{webtorrent.io}}: il sistema sfrutta la rete BitTorrent e permette di condividere i contenuti man mano che vengono scaricati da altri utenti.
	\paragraph*{}
	Sono state realizzate anche soluzioni \engl{peer-to-peer} per gli \engl{streaming} \engl{real-time}; una di queste è WebRTC:\@ tra le molteplici funzionalità dello \engl{standard} è inclusa la possibilità di ritrasmettere i contenuti ricevuti agli altri utenti collegati allo stesso \engl{stream}.

	\subsubsection{Analisi delle soluzioni esistenti}
	Propongo di seguito un'analisi delle più famose soluzioni commerciali di \engl{streaming}.
		\paragraph{YouTube}
		YouTube utilizza lo \engl{standard} \gls{RTSP} per l'\engl{inbound} di \engl{stream} video \engl{real-time}, mentre il principale protocollo per la trasmissione è MPEG-DASH;\@ questa scelta permette di ottenere una piattaforma facilmente accessibile, pur perdendo una parte del throughput a causa del protocollo di trasporto. YouTube permette \engl{streaming}-on demand dei video caricati dagli utenti, inoltre ha integrato il servizio con un sistema live-\engl{streaming} ibrido nel Settembre del 2016. Attualmente YouTube supporta video filmati con tecnologie 3D e video 360\textdegree, integrati con la piattaforma Google Cardboard. Il formato \engl{standard} utilizzato da YouTube è H.264/MPEG-4 AVC, ma è in corso una migrazione verso il formato WebM.
		\paragraph*{}
		YouTube associa al suo servizio di \engl{streaming} una serie di servizi paralleli, come il sistema di monetizzazione di AdMob e di pubblicità AdSense e quello di profilazione e analisi Google Analytics.
	
		\paragraph{Netflix}
		Netflix è un servizio di \engl{streaming} \engl{on-demand} di serie TV e film ad abbonamento. Il sistema utilizza lo \engl{standard} \gls{MPEG-DASH} e integra una protezione \gls{DRM} sui dati inviati. I video, scalati in diverse qualità, vengono spezzati in chunk e richiesti ad uno ad uno dal \engl{client}; la scelta della qualità da visualizzare viene calcolata in base al tempo necessario per scaricare la precedente.
		\paragraph*{}
		Netflix si avvale dei servizi \engl{cloud} di Amazon per soddisfare le richieste in modo scalabile e distribuito; inoltre, ha stipulato accordi con i principali \gls{ISP} dei paesi in cui il servizio è attivo, per poter sfruttare le \gls{CDN} locali e migliorare i tempi di risposta e di caricamento dei contenuti.
	
		\paragraph{Red5 Pro}
		Red5 Pro è una piattaforma ibrida, che offre servizi di \engl{streaming} facilmente integrabili con applicazioni e siti. Attualmente i protocolli supportati sono \gls{RTMP}, \gls{RTSP}, \gls{RTMPT}, \gls{RTSP}, \gls{HLS}, mentre i formati sono FLV e H.264 MP4; inoltre dispone di \gls{SDK} per Android e iOS.\@ Red5 Pro permette di controllare direttamente il \engl{bitrate} di \engl{outbound} dai server e offre i servizi di \engl{videochat} a due vie o in gruppo. Da poco è stato aggiunto supporto anche a WebRTC.\@
	
		\paragraph{Contus Vplay}
		Contus Vplay è una piattaforma di \engl{streaming} ibrida, basata su \gls{AWS}. Il sistema sfrutta i servizi \gls{S3} e Elastic Transcode di Amazon, per la transcodifica dei file video caricati dagli utenti, e il Wowza Streaming Engine\footnote{Sito web di Wowza Streaming Engine: \href{https://www.wowza.com/products/streaming-engine}{www.wowza.com/products/streaming-engine}}, il motore di transcodifica leader del mercato e che supporta la conversione ``al volo'', il quale viene installato in istanze server \gls{EC2}.
		\begin{figure}[H]
			\begin{center}
				\includegraphics[width=16.5cm,height=10cm,keepaspectratio]{immagini/contus-vplay-cloud-architecture.jpg}
				\caption[Architettura di Contus Vplay]{Architettura di Contus Vplay
				\\
				Source: sito web di Contus Vplay \href{http://www.contus.com/video-on-demand-solution.php}{www.contus.com/video-on-demand-solution.php}}
			\end{center}
		\end{figure}
		\paragraph*{} Il servizio è predisposto per soddisfare le richieste dei clienti tramite tre protocolli, Apple \gls{HLS}, \gls{MPEG-DASH} e Microsoft Smooth Streaming, sulle principali piattaforme e con multiple qualità del video. La gestione dei contenuti avviene tramite una dashboard che viene mantenuta tramite una combinazione di server \gls{EC2} e il servizio CloudFront di \gls{AWS}. Oltre al sistema di \engl{streaming}, Contus offre una serie di servizi allegati, come analisi sul traffico, profilazione, monetizzazione sugli annunci pubblicitari, cifratura delle connessioni e \gls{SDK} per le maggiori piattaforme.
	
		\paragraph{Streamroot}
		Streamroot offre un servizio di \engl{streaming} ibrido. La sua particolarità rispetto alle altre soluzioni è quella di utilizzare un sistema di condivisione \engl{peer-to-peer} dei contenuti scaricati dai clienti. In questo modo ciascun cliente non solo può contare sulla \gls{CDN}, ma anche su ogni altro utente che sta visualizzando gli stessi contenuti. Secondo i dati riportati dal servizio, questo tipo di distribuzione, unita al sistema di \gls{CDN}, permette di abbassare il carico sui server di circa il 75\%. Streamroot viene utilizzato da molte aziende che hanno necessità di trasmettere ingenti quantità di dati, tra le quali Dailymotion, Eurosport e Canal+.
	

\section{Analisi dei requisiti}
	\subsection{Analisi preliminare}
		L'analisi preliminare si è focalizzata sulla definizione degli attori e degli obiettivi e delle funzionalità principali del \engl{software} da produrre.
		\paragraph*{}
		Il \engl{software} deve gestire l'autenticazione di amministratori e utenti; questi hanno, in entrambi i casi, hanno un'identità univoca e un token di accesso. Gli amministratori hanno la possibilità di creare e rimuovere canali, aggiungere e togliere utenti e gestirne l'autenticazione.
		Gli utenti possono autenticarsi, inviare messaggi nei canali dove sono registrati o abbandonarne uno.
		\paragraph*{}
		Ho definito, in collaborazione con gli sviluppatori del \engl{team} che si occupa del progetto, gli attori del sistema, le interazioni che possono intraprendere e i risultati di ciascuna di queste. Per fare ciò ho definito i casi d'uso tramite un diagramma \gls{UML}.\@

	\subsection{Definizione dei casi d'uso}
		Segue una versione ristretta della definizione dei casi d'uso trovati durante l'analisi dei requisiti.
		\begin{figure}[H]
			\begin{center}
			\includegraphics[width=16.5cm,height=22.5cm,keepaspectratio]{UML/png/Use Case Model__Use Cases_0}
			\caption{Diagramma dei casi d'uso del sistema}
			\end{center}
		\end{figure}

		\subsubsection{Attori}
		\begin{itemize}
			\item \textbf{Client}: un utente che interagisce con il sistema;
			\item \textbf{Unauthenticated Client}: un \engl{client} non ancora autenticato;
			\item \textbf{Authenticated Client}: un \engl{client} che ha eseguito l'autenticazione ed è registrato all'interno di almeno un canale;
			\item \textbf{Admin}: un utente o un sistema automatico che ha il ruolo di amministratore del servizio offerto dal server.
		\end{itemize}

		\subsubsection{Casi d'uso di Unauthenticated Client}
		\begin{itemize}
			\item \textbf{Authenticate client}: L'utente esegue l'autenticazione su sistema come \engl{client};
			\item \textbf{Authenticate admin}: L'utente esegue l'autenticazione su sistema come amministratore.
		\end{itemize}

		\subsubsection{Casi d'uso di Authenticated Client}
		\begin{itemize}
			\item \textbf{Send message}: L'utente invia un messaggio all'interno di un canale in cui è registrato; 
			\item \textbf{Leave channel}: L'utente lascia il canale e viene deregistrato; 
			\item \textbf{Get subscriptions}: L'utente ottiene la lista dei canali nei quali è registrato; 
		\end{itemize}

		\subsubsection{Casi d'uso di Admin}
		\begin{itemize}
			\item \textbf{Add channel}: L'Amministratore crea un nuovo canale;
			\item \textbf{Remove channel}: L'amministratore elimina un canale;
			\item \textbf{Get channel list}: L'amministratore ottiene la lista dei canali registrati;
			\item \textbf{Add user to channel}: L'amministratore registra un utente in un certo canale;
			\item \textbf{Remove user from channel}: L'amministratore rimuove un utente da un canale;
			\item \textbf{Get users in channel}: L'amministratore ottiene la lista degli utenti registrati in un canale;
			\item \textbf{Set user token}: L'amministratore imposta il token di autenticazione di un utente;
			\item \textbf{Get user token}: L'amministratore ottiene il token di autenticazione di un utente;
			\item \textbf{Reset user token}: L'amministratore resetta il token di autenticazione di un utente;
			\item \textbf{Get user channels}: L'amministratore ottiene la lista dei canali in cui un certo utente è registrato.
		\end{itemize}
		

\section{Architettura della piattaforma}
Una volta definiti i casi d'uso, ho proceduto alla scelta dei protocolli di rete da utilizzare e la progettazione strutturale del sistema.
	\subsection{Protocolli}
	Ho eseguito la scelta dei protocolli in collaborazione con il \engl{team} di sviluppatori che lavorava sul \engl{client} Android, per trovare la migliore soluzione in termini di latenza, throughput e complessità di implementazione.
	\paragraph*{}
	I protocolli UDP sono stati scartati a causa dei problemi con \engl{firewall} riportati precedentemente.
	Le specifiche del servizio richiedono che sia possibile inviare messaggi di qualsiasi tipo, sia atomici, sia \engl{stream} di dati. Per semplificare l'invio di dati generici, senza essere necessariamente legati ad un certo protocollo dello strato applicativo, abbiamo deciso di utilizzare dei WebSocket ed esistono implementazioni \engl{open-source} dello \engl{standard} per la maggior parte delle piattaforme, inclusi iOS e Android e Java, rendendo, quindi, l'implementazione di \engl{client} e server più semplice.
	\\
	Lo standard WebSocket utilizza TCP per trasmettere stream di byte, esattamente come succede sui comuni socket, ma integra una serie di controlli di rete e di sicurezza, fondamentali per l'utilizzo sicuro tramite Internet.
	
	\subsection{Diagramma delle classi}
	Segue in Fig.~\ref{diagrammaclassi} il diagramma \gls{UML} delle classi semplificato.

	\begin{figure}[H]
		\begin{center}
			\includegraphics[width=16.5cm,height=22.5cm,keepaspectratio]{UML/png/Design Model__SimpleClasses_6}
			\caption{Diagramma delle classi del sistema}\label{diagrammaclassi}
		\end{center}
	\end{figure}

		\subsubsection{ConcreteModel e interfacce del modello}
	Il modello è responsabile del salvataggio e della gestione delle informazioni legate agli utenti, ai canali, alle registrazioni e ai messaggi da inviare. Per organizzare chiaramente le sue funzionalità ho utilizzato interfacce molto specifiche.

		\subsubsection{IUserID e IChannelKey}
	Per identificare univocamente un utente o un canale ho designato due interfacce per due classi di oggetti che permettono di ottenere un identificativo univoco sotto forma di stringa; in questo modo è possibile referenziare uno di questi oggetti indicandone il solo ID.\@

		\subsubsection{User}
	La classe astratta User definisce un utente e permette di caricare ed estrarre informazioni sui profili degli utenti.

		\subsubsection{IChannel e AbstractChannel}
	IChannel e AbstractChannel individuano le funzionalità e i dati di base di un canale, come il suo nome e il suo scopo.

		\subsubsection{Message, WrappedMessage e MessageContent}
	Message rappresenta un messaggio da inviare, il cui contenuto è un insieme di MessageContent. Al fine di garantire la possibilità di inviare qualsiasi tipo di contenuto tramite un messaggio, MessageContent eredita direttamente dalla classe Java Serializable, ma non impone altri limiti. WrappedMessage aggiunge ad un messaggio le informazioni per spedirlo, ovvero la ChannelKey e l'UserID del destinatario.

		\subsubsection{Controller di Admin, User e Beacon}
	I tre controller del sistema sono singleton e gestiscono le interazioni e aggiornano il modello. AdminServerController e UserServerController eseguono, rispettivamente, le azioni ricevute da un amministratore e da un utente. BeaconServerController è incaricato della creazione dei messaggi e del loro invio; utilizza un pattern command e una coda intelligente.

\subsection{Tecnologie utilizzate}
	\subsubsection{Linguaggio --- Java}
	Il linguaggio Java è stato scelto innanzitutto per la possibilità di eseguire il codice su qualsiasi piattaforma che offra una \gls{JVM};\@ in questo modo il sistema può essere eseguito su server con diversi sistemi operativi senza la necessità di riscriverne componenti o di essere ricompilato. Un altro vantaggio è quello di poter riutilizzare parte del codice scritto nel \engl{client} Android, riducendone i tempi di sviluppo e aumentando la qualità del codice.

	\subsubsection{Piattaforma --- Apache Tomcat 8}
	Un servizio Java che espone dei WebSocket ha bisogno di una piattaforma che ne gestisca gli accessi ovvero un componente che implementi la classe JavaServer. Per questo progetto ho deciso di utilizzare Apache Tomcat 8 per il suo supporto nativo ai WebSocket. Inoltre, Tomcat 8 è il server Java \engl{open-source} più diffuso, la sua documentazione è sufficientemente chiara e completa e attualmente è l'unico a supportare completamente l'ultima versione di Java.

	\subsubsection{Tipo di dati scambiati --- \gls{JSON} vs \gls{XML}}
	Per poter inviare messaggi tramite un WebSocket è necessario definire una codifica. L'implementazione \engl{standard} di Java permette di utilizzare stringhe di byte, stringhe di testo oppure di definire un codificatore e un decodificatore per gestire oggetti più complessi. Per semplificare lo sviluppo della piattaforma ho preferito utilizzare una codifica testuale, che mi permettesse di eseguire \engl{test} automatici e manuali tramite semplici messaggi testuali. Le due codifiche maggiormente utilizzate che permettono di descrivere oggetti anche molto complessi sono \gls{JSON} e \gls{XML}.\@ Entrambe le codifiche soddisfano pienamente i requisiti necessari, ma \gls{JSON} è molto meno prolisso di \gls{XML};\@ per questo motivo ho preferito tale linguaggio.

	\subsubsection{Strumenti di supporto}
		\paragraph{Strumenti di codifica}
		Lo strumento che ho utilizzato per codificare ed eseguire i \engl{test} sul sistema è stato l'IDE IntelliJ Idea, sviluppato da JetBrains, nella versione \engl{open-source} ``Community Edition''. Questo \engl{editor}, progettato appositamente per Java, è ricco di utili strumenti per velocizzare la codifica e l'analisi, come lo smart code completion, per i suggerimenti contestuali per il completamento del codice, i code template, per la rapida generazione di strutture di codice prestabilite, e sistemi di analisi e di automatizzazione dei task, come l'aggiornamento delle dipendenze o l'esecuzione dei \engl{test}.

		\paragraph{Strumenti di versionamento}
		Lo strumento di versionamento utilizzato durante il progetto è stato quello comunemente utilizzato dall'azienda, ovvero Git, con l'ausilio dei server di Bitbucket per l'automatizzazione di alcuni \engl{test}.
		\\
		Il vantaggio di aver utilizzato Git durante lo sviluppo è stato quello di poter condividere velocemente le ultime modifiche con gli altri sviluppatori, pur mantenendo baseline sicure e testate. Ciò significa che, se anche ci fossero stati dei gravi problemi in uno dei PC degli sviluppatori, tutto il codice che fosse stato già caricato su uno degli altri client o sul server sarebbe stato al sicuro e facilmente reperibile.
		
		\paragraph{Strumenti di test e verifica}
		Ho scelto di utilizzare il \engl{framework} JUnit 4 per eseguire \engl{test} di unità e di integrazione dopo un'attenta analisi delle sue funzionalità. Il sistema di \engl{test} si è rivelato semplice ed efficace; mi ha permesso di realizzare \engl{test} significativi con poco sforzo e ha contribuito alla buona qualità del codice. L'integrazione dell'IDE usato con JUnit permette anche di esportare i dati dei \engl{test}, del coverage e delle analisi in formato \gls{HTML}, facilmente consultabile anche senza strumenti di sviluppo dedicati. JUnit 4 è stato utile anche per eseguire benchmark per valutare l'efficacia del prodotto, tramite la realizzazione di una simulazione di conversazione tra un numero definito di utenti.
		\begin{figure}[H]
			\begin{center}
				\includegraphics[width=16.5cm,height=10cm,keepaspectratio]{immagini/intellij-tests}
				\caption{Sistema integrato di esecuzione dei \engl{test} in IntelliJ Idea}
			\end{center}
		\end{figure}
		
		\paragraph{Strumenti di analisi di rete}
		Durante i \engl{test} sulla sicurezza delle trasmissioni ho dovuto assicurarmi che il sistema inviasse contenuti sensibili non cifrati; per questo motivo ho avuto necessità di registrare le conversazioni tra alcuni utenti simulati. Per eseguire queste operazioni ho utilizzato Wireshark, un \engl{software} \engl{open-source} per l'analisi del traffico di rete. Wireshark permette di effettuare sniffing del traffico di rete, di visualizzare ciascun pacchetto e di filtrare facilmente i contenuti d'interesse. Tramite un'analisi eseguita con questo strumento ho potuto garantire che tutti i dati scambiati fossero cifrati end to end tramite \gls{TLS}.\@
		
		\paragraph{Strumenti di continuous integration}
		Per poter garantire l'indipendenza dalla piattaforma di sviluppo, in particolare durante l'esecuzione dei \engl{test}, ho utilizzato un sistema \gls{Docker}. Questo strumento permette di configurare facilmente l'installazione e la configurazione di un \engl{software} in sviluppo su una macchina virtuale minimale e di eseguire \engl{test} e script su di essa. Tramite l'integrazione con Bitbucket ho potuto automatizzare queste attività, fornendo una maggiore qualità al codice senza dover svolgere compiti ripetitivi e onerosi in termini di tempo.
		\paragraph*{}
		Tramite le \engl{pipeline}, il sistema di configurazione delle operazioni sui container \gls{Docker} di Bitbucket, ho potuto automatizzare anche il deploy dell'applicazione, limitando i tempi di manutenzione necessari al suo aggiornamento manuale.

		\paragraph{Strumenti di debugging}
		Durante la codifica, specialmente durante la scrittura delle componenti per la gestione dei messaggi, mi è stato molto utile la possibilità di eseguire parti del programma in modalità debug. Questa permette di interrompere temporaneamente l'esecuzione in punti prestabiliti, semplificando la comprensione della sequenza di azioni avvenute e fornendo maggiori informazioni sulla \engl{stack trace} del programma, ovvero la pila di funzioni che stanno venendo eseguite.
		\\
		IntelliJ Idea integra questa modalità e raccoglie le informazioni ottenute in un'interfaccia semplice da comprendere. L'editor mostra anche lo stato delle singole variabili, sia su una scheda apposita, sia direttamente sul codice. 
		\begin{figure}[H]
			\begin{center}
				\includegraphics[width=16.5cm,height=22.5cm,keepaspectratio]{immagini/intellij-debugger}
				\caption{Integrazione della modalità di debug in IntelliJ Idea}
			\end{center}
		\end{figure}

\section{Qualifica}
%TODO: essere più quantitativo, nell'intera sezione
	\subsection{Verifica}
	la verifica di un prodotto è l'insieme delle operazioni atte a garantirne la qualità e il rispetto delle specifiche definite durante la progettazione. Può essere riassunto nella domanda ``\engl{did I build the system right?}''
		\subsubsection{Analisi statica}
		L'analisi statica consiste nei \engl{test} che possono essere eseguiti sul prodotto senza compilare ed eseguire il codice. In questo tipo di \engl{test} possiamo trovare, quindi, analisi grammaticali del codice, \engl{test} su errori tipici, \engl{test} sui file di configurazione, controlli sulla duplicazione del codice, ecc.
		\paragraph*{}
		L'analisi statica del prodotto è stata delegata ai \engl{test} interni dell'IDE utilizzato, IntelliJ Idea. Questo esegue molti dei \engl{test} sopra citati in modo automatico, mentre il codice viene scritto, fornendo utili suggerimenti.
		\paragraph*{}
		Una funzionalità che mi è sembrata particolarmente utile durante la verifica è il controllo automatico sulle classi importate: l'IDE controlla quali classi importate nel file vengono effettivamente utilizzate, segnala le mancanti offrendo suggerimenti e permette di eliminare quelle non necessarie.

		\subsubsection{Analisi dinamica}
		Con analisi dinamica si intendono le operazioni di controllo fatte sul codice compilato ed eseguito. Questi \engl{test} includono asserzioni sullo stato dell'esecuzione ed esecuzioni controllate dei componenti, sia singolarmente, sia facendoli interagire l'uno con l'altro.
		\paragraph*{}
		Ho programmato l'analisi dinamica del prodotto durante l'analisi e la progettazione, per poi essere implementata durante la codifica. Ho realizzato i \engl{test} di unità delle singole componenti e di integrazione, verificando che eseguissero i compiti assegnati dalle interfacce nel modo corretto, per poi passare ai \engl{test} di sistema, eseguiti tramite simulazioni controllate.
		\paragraph*{}
		Un vantaggio importante nella scelta di eseguire \engl{test} di sistema automatici è stata quella di poter valutare il prodotto nella sua interezza, generando un report chiaro sullo stato di sviluppo e sulle prestazioni ottenute. In particolare, dopo una prima fase di codifica ho scoperto un errore sulla gestione di alcuni task da parte del componente dedicato al reinvio dei messaggi proprio grazie a un \engl{test} di questo tipo; alcuni messaggi non venivano inviati e le sessioni stabilite con i \engl{client} venivano chiuse anticipatamente se il numero di utenti superava una certa soglia. La simulazione ha evidenziato questo problema e mi ha permesso di individuare e correggere il bug in poco tempo.

	\subsection{Validazione}
	La validazione di un prodotto consiste nel controllare che tutti i requisiti del prodotto vengano effettivamente soddisfatti e può essere riassunta nella domanda ``\engl{did I build the right system?}''
		\subsubsection{Validazione interna}
		Dato che il prodotto è destinato ad essere un componente di una più grande piattaforma, ancora in sviluppo, la validazione è stata interna. Il project manager e il mio tutor aziendale hanno eseguito tutti i \engl{test}, le simulazioni e, come prova finale, hanno provato a comunicare tramite due \engl{client} WebSocket.
